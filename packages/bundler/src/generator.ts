/**
 * Code generator for base images
 *
 * Transforms image definitions into importable packages with:
 * - Side-effect provider registration
 * - createAgent() factory
 * - Utility exports
 * - Metadata exports
 */

import type { ImageDefinition } from '@dexto/core';
import type { GeneratedCode } from './types.js';

/**
 * Generate JavaScript entry point for an image
 */
export function generateEntryPoint(
    definition: ImageDefinition,
    coreVersion: string
): GeneratedCode {
    const warnings: string[] = [];

    // Generate imports section
    const imports = generateImports(definition);

    // Generate provider registration section
    const registrations = generateProviderRegistrations(definition);

    // Generate factory function
    const factory = generateFactory();

    // Generate utility exports
    const utilityExports = generateUtilityExports(definition);

    // Generate metadata export
    const metadata = generateMetadata(definition, coreVersion);

    // Combine all sections
    const js = `// AUTO-GENERATED by @dexto/bundler
// Do not edit this file directly. Edit dexto.image.ts instead.

${imports}

${registrations}

${factory}

${utilityExports}

${metadata}
`;

    // Generate TypeScript definitions
    const dts = generateTypeDefinitions(definition);

    return { js, dts };
}

function generateImports(definition: ImageDefinition): string {
    const imports: string[] = [];

    // Core imports
    imports.push(`import { DextoAgent } from '@dexto/core';`);

    // Registry imports based on provider categories
    const registries: string[] = [];
    if (definition.providers.blobStore) registries.push('blobStoreRegistry');
    if (definition.providers.customTools) registries.push('customToolRegistry');
    if (definition.providers.plugins) registries.push('pluginRegistry');
    if (definition.providers.compression) registries.push('compressionRegistry');

    if (registries.length > 0) {
        imports.push(`import { ${registries.join(', ')} } from '@dexto/core';`);
    }

    // Provider imports (using relative paths from image package)
    for (const [category, config] of Object.entries(definition.providers)) {
        if (!config || !config.providers) continue;

        // For now, assume providers are exported from ./providers/{category}.js
        imports.push(`// ${category} providers`);
        imports.push(`import * as ${category}Providers from './providers/${category}.js';`);
    }

    return imports.join('\n');
}

function generateProviderRegistrations(definition: ImageDefinition): string {
    const registrations: string[] = [];
    registrations.push('// SIDE EFFECT: Register providers on import');
    registrations.push('');

    // Generate registrations for each category
    for (const [category, config] of Object.entries(definition.providers)) {
        if (!config) continue;

        if (config.providers) {
            // Direct provider registration
            const registryMap: Record<string, string> = {
                blobStore: 'blobStoreRegistry',
                customTools: 'customToolRegistry',
                plugins: 'pluginRegistry',
                compression: 'compressionRegistry',
            };

            const registryName = registryMap[category];
            if (registryName) {
                registrations.push(`// Register ${category} providers`);
                registrations.push(`for (const provider of Object.values(${category}Providers)) {`);
                registrations.push(
                    `    if (provider && typeof provider === 'object' && 'type' in provider) {`
                );
                registrations.push(`        ${registryName}.register(provider);`);
                registrations.push(`    }`);
                registrations.push(`}`);
                registrations.push('');
            }
        }

        if (config.register) {
            // Async registration function with duplicate prevention
            registrations.push(`// Register ${category} via custom function`);
            registrations.push(`await (async () => {`);
            registrations.push(`    // Custom registration logic from dexto.image.ts`);
            registrations.push(`    // NOTE: This is called at module init time`);
            registrations.push(`    // Wrapped to prevent duplicate registrations`);
            registrations.push(`    try {`);
            registrations.push(
                `        ${config.register
                    .toString()
                    .replace(/^async\s*\(\)\s*=>\s*{/, '')
                    .replace(/}$/, '')}`
            );
            registrations.push(`    } catch (err) {`);
            registrations.push(`        // Ignore duplicate registration errors`);
            registrations.push(`        if (!err.message?.includes('already registered')) {`);
            registrations.push(`            throw err;`);
            registrations.push(`        }`);
            registrations.push(`    }`);
            registrations.push(`})();`);
            registrations.push('');
        }
    }

    return registrations.join('\n');
}

function generateFactory(): string {
    return `/**
 * Create a Dexto agent using this image's registered providers.
 *
 * @param config - Agent configuration
 * @param configPath - Optional path to config file
 * @returns DextoAgent instance with providers already registered
 */
export function createAgent(config, configPath) {
    return new DextoAgent(config, configPath);
}`;
}

function generateUtilityExports(definition: ImageDefinition): string {
    if (!definition.utils || Object.keys(definition.utils).length === 0) {
        return '// No utilities defined for this image';
    }

    const exports: string[] = [];
    exports.push('// Utility exports');

    for (const [name, path] of Object.entries(definition.utils)) {
        exports.push(`export * from '${path}';`);
    }

    return exports.join('\n');
}

function generateMetadata(definition: ImageDefinition, coreVersion: string): string {
    const metadata = {
        name: definition.name,
        version: definition.version,
        description: definition.description,
        target: definition.target || 'custom',
        constraints: definition.constraints || [],
        builtAt: new Date().toISOString(),
        coreVersion: coreVersion,
    };

    return `/**
 * Image metadata
 * Generated at build time
 */
export const imageMetadata = ${JSON.stringify(metadata, null, 4)};`;
}

function generateTypeDefinitions(definition: ImageDefinition): string {
    return `// AUTO-GENERATED TypeScript definitions
// Do not edit this file directly

import type { DextoAgent, AgentConfig, ImageMetadata } from '@dexto/core';

/**
 * Create a Dexto agent using this image's registered providers.
 */
export declare function createAgent(config: AgentConfig, configPath?: string): DextoAgent;

/**
 * Image metadata
 */
export declare const imageMetadata: ImageMetadata;

// Re-export utilities if any are defined
${
    definition.utils
        ? Object.keys(definition.utils)
              .map((name) => `export * from '${definition.utils![name]}';`)
              .join('\n')
        : ''
}
`;
}
