/**
 * Code generator for base images
 *
 * Transforms image definitions into importable packages with:
 * - Side-effect provider registration
 * - createAgent() factory
 * - Utility exports
 * - Metadata exports
 */

import type { ImageDefinition } from '@dexto/core';
import type { GeneratedCode } from './types.js';
import type { DiscoveredProviders } from './bundler.js';

/**
 * Generate JavaScript entry point for an image
 */
export function generateEntryPoint(
    definition: ImageDefinition,
    coreVersion: string,
    discoveredProviders?: DiscoveredProviders
): GeneratedCode {
    const warnings: string[] = [];

    // Generate imports section
    const imports = generateImports(definition, discoveredProviders);

    // Generate provider registration section
    const registrations = generateProviderRegistrations(definition, discoveredProviders);

    // Generate factory function
    const factory = generateFactory();

    // Generate utility exports
    const utilityExports = generateUtilityExports(definition);

    // Generate metadata export
    const metadata = generateMetadata(definition, coreVersion);

    // Combine all sections
    const js = `// AUTO-GENERATED by @dexto/bundler
// Do not edit this file directly. Edit dexto.image.ts instead.

${imports}

${registrations}

${factory}

${utilityExports}

${metadata}
`;

    // Generate TypeScript definitions
    const dts = generateTypeDefinitions(definition);

    return { js, dts };
}

function generateImports(
    definition: ImageDefinition,
    discoveredProviders?: DiscoveredProviders
): string {
    const imports: string[] = [];

    // Import base image first (if extending) - triggers side-effect provider registration
    if (definition.extends) {
        imports.push(`// Import base image for provider registration (side effect)`);
        imports.push(`import '${definition.extends}';`);
        imports.push(``);
    }

    // Core imports
    imports.push(`import { DextoAgent } from '@dexto/core';`);

    // Determine which registries are needed based on discovered providers or manual config
    const registries: Set<string> = new Set();

    if (discoveredProviders) {
        if (discoveredProviders.blobStore.length > 0) registries.add('blobStoreRegistry');
        if (discoveredProviders.customTools.length > 0) registries.add('customToolRegistry');
        if (discoveredProviders.plugins.length > 0) registries.add('pluginRegistry');
        if (discoveredProviders.compression.length > 0) registries.add('compressionRegistry');
    }

    // Also check manual provider registration from definition
    if (definition.providers.blobStore) registries.add('blobStoreRegistry');
    if (definition.providers.customTools) registries.add('customToolRegistry');
    if (definition.providers.plugins) registries.add('pluginRegistry');
    if (definition.providers.compression) registries.add('compressionRegistry');

    if (registries.size > 0) {
        imports.push(`import { ${Array.from(registries).join(', ')} } from '@dexto/core';`);
    }

    // Import discovered providers
    if (discoveredProviders) {
        const categories = [
            { key: 'blobStore', label: 'Blob Storage' },
            { key: 'customTools', label: 'Custom Tools' },
            { key: 'compression', label: 'Compression' },
            { key: 'plugins', label: 'Plugins' },
        ] as const;

        for (const { key, label } of categories) {
            const providers = discoveredProviders[key];
            if (providers.length > 0) {
                imports.push(``);
                imports.push(`// ${label} providers (auto-discovered)`);
                providers.forEach((path, index) => {
                    const varName = `${key}Provider${index}`;
                    imports.push(`import * as ${varName} from '${path}';`);
                });
            }
        }
    }

    return imports.join('\n');
}

function generateProviderRegistrations(
    definition: ImageDefinition,
    discoveredProviders?: DiscoveredProviders
): string {
    const registrations: string[] = [];

    if (definition.extends) {
        registrations.push(
            `// Base image providers already registered via import of '${definition.extends}'`
        );
        registrations.push('');
    }

    registrations.push('// SIDE EFFECT: Register providers on import');
    registrations.push('');

    // Auto-register discovered providers
    if (discoveredProviders) {
        const categoryMap = [
            { key: 'blobStore', registry: 'blobStoreRegistry', label: 'Blob Storage' },
            { key: 'customTools', registry: 'customToolRegistry', label: 'Custom Tools' },
            { key: 'compression', registry: 'compressionRegistry', label: 'Compression' },
            { key: 'plugins', registry: 'pluginRegistry', label: 'Plugins' },
        ] as const;

        for (const { key, registry, label } of categoryMap) {
            const providers = discoveredProviders[key];
            if (providers.length === 0) continue;

            registrations.push(`// Auto-register ${label} providers`);
            providers.forEach((path, index) => {
                const varName = `${key}Provider${index}`;
                registrations.push(`// From ${path}`);
                registrations.push(`for (const exported of Object.values(${varName})) {`);
                registrations.push(
                    `    if (exported && typeof exported === 'object' && 'type' in exported && 'create' in exported) {`
                );
                registrations.push(`        try {`);
                registrations.push(`            ${registry}.register(exported);`);
                registrations.push(
                    `            console.log(\`âœ“ Registered ${key}: \${exported.type}\`);`
                );
                registrations.push(`        } catch (err) {`);
                registrations.push(`            // Ignore duplicate registration errors`);
                registrations.push(
                    `            if (!err.message?.includes('already registered')) throw err;`
                );
                registrations.push(`        }`);
                registrations.push(`    }`);
                registrations.push(`}`);
            });
            registrations.push('');
        }
    }

    // Handle manual registration functions (backwards compatibility)
    for (const [category, config] of Object.entries(definition.providers)) {
        if (!config) continue;

        if (config.register) {
            // Async registration function with duplicate prevention
            registrations.push(`// Register ${category} via custom function (from dexto.image.ts)`);
            registrations.push(`await (async () => {`);
            registrations.push(`    try {`);
            registrations.push(
                `        ${config.register
                    .toString()
                    .replace(/^async\s*\(\)\s*=>\s*{/, '')
                    .replace(/}$/, '')}`
            );
            registrations.push(`    } catch (err) {`);
            registrations.push(`        // Ignore duplicate registration errors`);
            registrations.push(`        if (!err.message?.includes('already registered')) {`);
            registrations.push(`            throw err;`);
            registrations.push(`        }`);
            registrations.push(`    }`);
            registrations.push(`})();`);
            registrations.push('');
        }
    }

    return registrations.join('\n');
}

function generateFactory(): string {
    return `/**
 * Create a Dexto agent using this image's registered providers.
 *
 * @param config - Agent configuration
 * @param configPath - Optional path to config file
 * @returns DextoAgent instance with providers already registered
 */
export function createAgent(config, configPath) {
    return new DextoAgent(config, configPath);
}

/**
 * Re-export registries for runtime customization.
 * This allows apps to add custom providers without depending on @dexto/core directly.
 */
export {
    customToolRegistry,
    pluginRegistry,
    compressionRegistry,
    blobStoreRegistry,
} from '@dexto/core';`;
}

function generateUtilityExports(definition: ImageDefinition): string {
    if (!definition.utils || Object.keys(definition.utils).length === 0) {
        return '// No utilities defined for this image';
    }

    const exports: string[] = [];
    exports.push('// Utility exports');

    for (const [name, path] of Object.entries(definition.utils)) {
        exports.push(`export * from '${path}';`);
    }

    return exports.join('\n');
}

function generateMetadata(definition: ImageDefinition, coreVersion: string): string {
    const metadata: Record<string, any> = {
        name: definition.name,
        version: definition.version,
        description: definition.description,
        target: definition.target || 'custom',
        constraints: definition.constraints || [],
        builtAt: new Date().toISOString(),
        coreVersion: coreVersion,
    };

    // Include extends information if present
    if (definition.extends) {
        metadata.extends = definition.extends;
    }

    return `/**
 * Image metadata
 * Generated at build time
 */
export const imageMetadata = ${JSON.stringify(metadata, null, 4)};`;
}

function generateTypeDefinitions(definition: ImageDefinition): string {
    return `// AUTO-GENERATED TypeScript definitions
// Do not edit this file directly

import type { DextoAgent, AgentConfig, ImageMetadata } from '@dexto/core';

/**
 * Create a Dexto agent using this image's registered providers.
 */
export declare function createAgent(config: AgentConfig, configPath?: string): DextoAgent;

/**
 * Image metadata
 */
export declare const imageMetadata: ImageMetadata;

/**
 * Re-exported registries for runtime customization
 */
export {
    customToolRegistry,
    pluginRegistry,
    compressionRegistry,
    blobStoreRegistry,
} from '@dexto/core';

// Re-export utilities if any are defined
${
    definition.utils
        ? Object.keys(definition.utils)
              .map((name) => `export * from '${definition.utils![name]}';`)
              .join('\n')
        : ''
}
`;
}
