/**
 * Code generator for base images
 *
 * Transforms image definitions into importable packages with:
 * - Side-effect provider registration
 * - createAgent() factory
 * - Utility exports
 * - Metadata exports
 */

import type { ImageDefinition } from './image-definition/types.js';
import type { GeneratedCode } from './types.js';
import type { DiscoveredProviders } from './bundler.js';

/**
 * Generate JavaScript entry point for an image
 */
export function generateEntryPoint(
    definition: ImageDefinition,
    coreVersion: string,
    discoveredProviders?: DiscoveredProviders
): GeneratedCode {
    // Generate imports section
    const imports = generateImports(definition, discoveredProviders);

    // Generate provider registration section
    const registrations = generateProviderRegistrations(definition, discoveredProviders);

    // Generate factory function
    const factory = generateFactory();

    // Generate utility exports
    const utilityExports = generateUtilityExports(definition);

    // Generate metadata export
    const metadata = generateMetadata(definition, coreVersion);

    // Combine all sections
    const js = `// AUTO-GENERATED by @dexto/bundler
// Do not edit this file directly. Edit dexto.image.ts instead.

${imports}

${registrations}

${factory}

${utilityExports}

${metadata}
`;

    // Generate TypeScript definitions
    const dts = generateTypeDefinitions(definition);

    return { js, dts };
}

function generateImports(
    definition: ImageDefinition,
    discoveredProviders?: DiscoveredProviders
): string {
    const imports: string[] = [];

    // Import base image first (if extending) - triggers side-effect provider registration
    if (definition.extends) {
        imports.push(`// Import base image for provider registration (side effect)`);
        imports.push(`import '${definition.extends}';`);
        imports.push(``);
    }

    // Core imports
    imports.push(`import { AgentConfigSchema } from '@dexto/agent-config';`);
    imports.push(`import { DextoAgent, createLogger } from '@dexto/core';`);

    // Always import registries since we re-export them in generateFactory()
    // This ensures the re-exports don't reference unimported identifiers
    imports.push(`import { customToolRegistry } from '@dexto/core';`);

    // Import discovered providers
    if (discoveredProviders) {
        const categories = [{ key: 'customTools', label: 'Custom Tools' }] as const;

        for (const { key, label } of categories) {
            const providers = discoveredProviders[key];
            if (providers.length > 0) {
                imports.push(``);
                imports.push(`// ${label} providers (auto-discovered)`);
                providers.forEach((path, index) => {
                    const varName = `${key}Provider${index}`;
                    imports.push(`import * as ${varName} from '${path}';`);
                });
            }
        }
    }

    return imports.join('\n');
}

function generateProviderRegistrations(
    definition: ImageDefinition,
    discoveredProviders?: DiscoveredProviders
): string {
    const registrations: string[] = [];

    if (definition.extends) {
        registrations.push(
            `// Base image providers already registered via import of '${definition.extends}'`
        );
        registrations.push('');
    }

    registrations.push('// SIDE EFFECT: Register providers on import');
    registrations.push('');

    // Auto-register discovered providers
    if (discoveredProviders) {
        const categoryMap = [
            { key: 'customTools', registry: 'customToolRegistry', label: 'Custom Tools' },
        ] as const;

        for (const { key, registry, label } of categoryMap) {
            const providers = discoveredProviders[key];
            if (providers.length === 0) continue;

            registrations.push(`// Auto-register ${label} providers`);
            providers.forEach((path, index) => {
                const varName = `${key}Provider${index}`;
                registrations.push(`// From ${path}`);
                registrations.push(`for (const exported of Object.values(${varName})) {`);
                registrations.push(
                    `    if (exported && typeof exported === 'object' && 'type' in exported && 'create' in exported) {`
                );
                registrations.push(`        try {`);
                registrations.push(`            ${registry}.register(exported);`);
                registrations.push(
                    `            console.log(\`âœ“ Registered ${key}: \${exported.type}\`);`
                );
                registrations.push(`        } catch (err) {`);
                registrations.push(`            // Ignore duplicate registration errors`);
                registrations.push(
                    `            if (!err.message?.includes('already registered')) throw err;`
                );
                registrations.push(`        }`);
                registrations.push(`    }`);
                registrations.push(`}`);
            });
            registrations.push('');
        }
    }

    // Handle manual registration functions (backwards compatibility)
    for (const [category, config] of Object.entries(definition.providers)) {
        if (!config) continue;

        if (config.register) {
            // Async registration function with duplicate prevention
            registrations.push(`// Register ${category} via custom function (from dexto.image.ts)`);
            registrations.push(`await (async () => {`);
            registrations.push(`    try {`);
            registrations.push(
                `        ${config.register
                    .toString()
                    .replace(/^async\s*\(\)\s*=>\s*{/, '')
                    .replace(/}$/, '')}`
            );
            registrations.push(`    } catch (err) {`);
            registrations.push(`        // Ignore duplicate registration errors`);
            registrations.push(`        if (!err.message?.includes('already registered')) {`);
            registrations.push(`            throw err;`);
            registrations.push(`        }`);
            registrations.push(`    }`);
            registrations.push(`})();`);
            registrations.push('');
        }
    }

    return registrations.join('\n');
}

function generateFactory(): string {
    return `/**
 * Create a Dexto agent using this image's registered providers.
 *
 * @param config - Agent configuration
 * @param configPath - Optional path to config file
 * @returns DextoAgent instance with providers already registered
 */
export function createAgent(config, configPath) {
    const validatedConfig = AgentConfigSchema.parse(config);
    const agentLogger = createLogger({ config: validatedConfig.logger, agentId: validatedConfig.agentId });
    return new DextoAgent({ config: validatedConfig, configPath, logger: agentLogger });
}

/**
 * Re-export registries for runtime customization.
 * This allows apps to add custom providers without depending on @dexto/core directly.
 */
export {
    customToolRegistry,
} from '@dexto/core';`;
}

function generateUtilityExports(definition: ImageDefinition): string {
    const sections: string[] = [];

    // Generate wildcard utility exports
    if (definition.utils && Object.keys(definition.utils).length > 0) {
        sections.push('// Utility exports');
        for (const [name, path] of Object.entries(definition.utils)) {
            sections.push(`export * from '${path}';`);
        }
    }

    // Generate selective named exports (filter out type-only exports for runtime JS)
    if (definition.exports && Object.keys(definition.exports).length > 0) {
        if (sections.length > 0) sections.push('');
        sections.push('// Selective package re-exports');
        for (const [packageName, exports] of Object.entries(definition.exports)) {
            // Check for wildcard re-export
            if (exports.length === 1 && exports[0] === '*') {
                sections.push(`export * from '${packageName}';`);
                continue;
            }

            // Filter out type-only exports (those starting with 'type ')
            const runtimeExports = exports.filter((exp) => !exp.startsWith('type '));
            if (runtimeExports.length > 0) {
                sections.push(`export {`);
                sections.push(`    ${runtimeExports.join(',\n    ')}`);
                sections.push(`} from '${packageName}';`);
            }
        }
    }

    if (sections.length === 0) {
        return '// No utilities or exports defined for this image';
    }

    return sections.join('\n');
}

function generateMetadata(definition: ImageDefinition, coreVersion: string): string {
    const metadata: Record<string, any> = {
        name: definition.name,
        version: definition.version,
        description: definition.description,
        target: definition.target || 'custom',
        constraints: definition.constraints || [],
        builtAt: new Date().toISOString(),
        coreVersion: coreVersion,
    };

    // Include extends information if present
    if (definition.extends) {
        metadata.extends = definition.extends;
    }

    // Include bundled plugins if present
    if (definition.bundledPlugins && definition.bundledPlugins.length > 0) {
        metadata.bundledPlugins = definition.bundledPlugins;
    }

    return `/**
 * Image metadata
 * Generated at build time
 */
export const imageMetadata = ${JSON.stringify(metadata, null, 4)};`;
}

function generateTypeDefinitions(definition: ImageDefinition): string {
    const sections: string[] = [];

    // Wildcard utility exports
    if (definition.utils && Object.keys(definition.utils).length > 0) {
        sections.push('// Utility re-exports');
        for (const path of Object.values(definition.utils)) {
            sections.push(`export * from '${path}';`);
        }
    }

    // Selective named exports
    if (definition.exports && Object.keys(definition.exports).length > 0) {
        if (sections.length > 0) sections.push('');
        sections.push('// Selective package re-exports');
        for (const [packageName, exports] of Object.entries(definition.exports)) {
            // Check for wildcard re-export
            if (exports.length === 1 && exports[0] === '*') {
                sections.push(`export * from '${packageName}';`);
                continue;
            }

            sections.push(`export {`);
            sections.push(`    ${exports.join(',\n    ')}`);
            sections.push(`} from '${packageName}';`);
        }
    }

    const utilityExports = sections.length > 0 ? '\n\n' + sections.join('\n') : '';

    return `// AUTO-GENERATED TypeScript definitions
// Do not edit this file directly

import type { AgentConfig } from '@dexto/agent-config';
import type { DextoAgent } from '@dexto/core';

/**
 * Create a Dexto agent using this image's registered providers.
 */
export declare function createAgent(config: AgentConfig, configPath?: string): DextoAgent;

/**
 * Image metadata
 */
export interface ImageMetadata {
    name: string;
    version: string;
    description: string;
    target?: string;
    constraints: string[];
    builtAt: string;
    coreVersion: string;
    extends?: string;
    bundledPlugins?: string[];
}

export declare const imageMetadata: ImageMetadata;

/**
 * Re-exported registries for runtime customization
 */
export {
    customToolRegistry,
} from '@dexto/core';${utilityExports}
`;
}
