/**
 * Code generator for images
 *
 * Transforms image definitions + convention folders into importable packages with:
 * - A typed `DextoImageModule` default export (no side effects)
 * - Optional utility re-exports
 */

import type { ImageDefinition } from './image-definition/types.js';
import type { GeneratedCode } from './types.js';
import type { DiscoveredProviders } from './bundler.js';

/**
 * Generate JavaScript entry point for an image
 */
export function generateEntryPoint(
    definition: ImageDefinition,
    discoveredProviders: DiscoveredProviders
): GeneratedCode {
    const imports = generateImports(definition, discoveredProviders);
    const helpers = definition.extends ? generateHelpers() : '';
    const imageModule = generateImageModule(definition, discoveredProviders);
    const utilityExports = generateUtilityExports(definition);

    const js = `// AUTO-GENERATED by @dexto/image-bundler
// Do not edit this file directly. Edit dexto.image.ts instead.

${imports}

${helpers}

${imageModule}

${utilityExports}
`;

    // Generate TypeScript definitions
    const dts = generateTypeDefinitions(definition);

    return { js, dts };
}

function sanitizeIdentifier(value: string): string {
    const sanitized = value.replace(/[^a-zA-Z0-9_$]/g, '_');
    if (/^[a-zA-Z_$]/.test(sanitized)) {
        return sanitized;
    }
    return `_${sanitized}`;
}

function toProviderImportSymbol(prefix: string, type: string): string {
    return sanitizeIdentifier(`${prefix}_${type}`);
}

function generateImports(
    definition: ImageDefinition,
    discoveredProviders: DiscoveredProviders
): string {
    const imports: string[] = [];

    if (definition.extends) {
        imports.push(`import baseImage from '${definition.extends}';`);
    }

    imports.push(`import { defaultLoggerFactory } from '@dexto/core';`);

    const toolProviders = [...discoveredProviders.tools].sort((a, b) =>
        a.type.localeCompare(b.type)
    );
    const pluginProviders = [...discoveredProviders.plugins].sort((a, b) =>
        a.type.localeCompare(b.type)
    );
    const compactionProviders = [...discoveredProviders.compaction].sort((a, b) =>
        a.type.localeCompare(b.type)
    );
    const blobProviders = [...discoveredProviders.storage.blob].sort((a, b) =>
        a.type.localeCompare(b.type)
    );
    const databaseProviders = [...discoveredProviders.storage.database].sort((a, b) =>
        a.type.localeCompare(b.type)
    );
    const cacheProviders = [...discoveredProviders.storage.cache].sort((a, b) =>
        a.type.localeCompare(b.type)
    );

    if (
        toolProviders.length > 0 ||
        pluginProviders.length > 0 ||
        compactionProviders.length > 0 ||
        blobProviders.length > 0 ||
        databaseProviders.length > 0 ||
        cacheProviders.length > 0
    ) {
        imports.push('');
        imports.push('// Providers (convention folders; each must `export const provider = ...`)');
    }

    for (const entry of toolProviders) {
        const symbol = toProviderImportSymbol('tools', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }
    for (const entry of pluginProviders) {
        const symbol = toProviderImportSymbol('plugins', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }
    for (const entry of compactionProviders) {
        const symbol = toProviderImportSymbol('compaction', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }
    for (const entry of blobProviders) {
        const symbol = toProviderImportSymbol('storage_blob', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }
    for (const entry of databaseProviders) {
        const symbol = toProviderImportSymbol('storage_database', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }
    for (const entry of cacheProviders) {
        const symbol = toProviderImportSymbol('storage_cache', entry.type);
        imports.push(`import { provider as ${symbol} } from '${entry.importPath}';`);
    }

    return imports.join('\n');
}

function generateHelpers(): string {
    return `function isPlainObject(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}

function mergeImageDefaults(baseDefaults, overrideDefaults) {
    if (!baseDefaults) return overrideDefaults;
    if (!overrideDefaults) return baseDefaults;

    const merged = { ...baseDefaults, ...overrideDefaults };
    for (const [key, baseValue] of Object.entries(baseDefaults)) {
        const overrideValue = overrideDefaults[key];
        if (!isPlainObject(baseValue) || !isPlainObject(overrideValue)) {
            continue;
        }
        merged[key] = {
            ...baseValue,
            ...overrideValue,
        };
    }
    return merged;
}`;
}

function generateUtilityExports(definition: ImageDefinition): string {
    const sections: string[] = [];

    // Generate wildcard utility exports
    if (definition.utils && Object.keys(definition.utils).length > 0) {
        sections.push('// Utility exports');
        for (const [name, path] of Object.entries(definition.utils)) {
            sections.push(`export * from '${path}';`);
        }
    }

    // Generate selective named exports (filter out type-only exports for runtime JS)
    if (definition.exports && Object.keys(definition.exports).length > 0) {
        if (sections.length > 0) sections.push('');
        sections.push('// Selective package re-exports');
        for (const [packageName, exports] of Object.entries(definition.exports)) {
            // Check for wildcard re-export
            if (exports.length === 1 && exports[0] === '*') {
                sections.push(`export * from '${packageName}';`);
                continue;
            }

            // Filter out type-only exports (those starting with 'type ')
            const runtimeExports = exports.filter((exp) => !exp.startsWith('type '));
            if (runtimeExports.length > 0) {
                sections.push(`export {`);
                sections.push(`    ${runtimeExports.join(',\n    ')}`);
                sections.push(`} from '${packageName}';`);
            }
        }
    }

    if (sections.length === 0) {
        return '// No utilities or exports defined for this image';
    }

    return sections.join('\n');
}

function generateImageModule(
    definition: ImageDefinition,
    discoveredProviders: DiscoveredProviders
): string {
    const derivedDefaults =
        definition.defaults !== undefined
            ? JSON.stringify(definition.defaults, null, 4)
            : 'undefined';

    const toolsEntries = discoveredProviders.tools
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('tools', entry.type);
            return `        ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const pluginEntries = discoveredProviders.plugins
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('plugins', entry.type);
            return `        ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const compactionEntries = discoveredProviders.compaction
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('compaction', entry.type);
            return `        ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const blobEntries = discoveredProviders.storage.blob
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('storage_blob', entry.type);
            return `            ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const databaseEntries = discoveredProviders.storage.database
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('storage_database', entry.type);
            return `            ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const cacheEntries = discoveredProviders.storage.cache
        .slice()
        .sort((a, b) => a.type.localeCompare(b.type))
        .map((entry) => {
            const symbol = toProviderImportSymbol('storage_cache', entry.type);
            return `            ${JSON.stringify(entry.type)}: ${symbol},`;
        });

    const metadataLines: string[] = [];
    metadataLines.push(`        name: ${JSON.stringify(definition.name)},`);
    metadataLines.push(`        version: ${JSON.stringify(definition.version)},`);
    metadataLines.push(`        description: ${JSON.stringify(definition.description)},`);

    if (definition.target !== undefined) {
        metadataLines.push(`        target: ${JSON.stringify(definition.target)},`);
    } else if (definition.extends) {
        metadataLines.push(`        target: baseImage.metadata.target,`);
    }

    if (definition.extends) {
        const derivedConstraints = JSON.stringify(definition.constraints ?? []);
        metadataLines.push(
            `        constraints: Array.from(new Set([...(baseImage.metadata.constraints ?? []), ...${derivedConstraints}])),`
        );
    } else if (definition.constraints !== undefined) {
        metadataLines.push(`        constraints: ${JSON.stringify(definition.constraints)},`);
    }

    const defaultsExpression = definition.extends
        ? `mergeImageDefaults(baseImage.defaults, ${derivedDefaults})`
        : derivedDefaults;

    const toolsSpread = definition.extends ? `        ...baseImage.tools,\n` : '';
    const pluginsSpread = definition.extends ? `        ...baseImage.plugins,\n` : '';
    const compactionSpread = definition.extends ? `        ...baseImage.compaction,\n` : '';

    const blobSpread = definition.extends ? `            ...baseImage.storage.blob,\n` : '';
    const databaseSpread = definition.extends ? `            ...baseImage.storage.database,\n` : '';
    const cacheSpread = definition.extends ? `            ...baseImage.storage.cache,\n` : '';

    const loggerExpression = definition.extends
        ? `baseImage.logger ?? defaultLoggerFactory`
        : `defaultLoggerFactory`;

    return `const image = {
    metadata: {
${metadataLines.join('\n')}
    },
    defaults: ${defaultsExpression},
    tools: {
${toolsSpread}${toolsEntries.join('\n')}
    },
    storage: {
        blob: {
${blobSpread}${blobEntries.join('\n')}
        },
        database: {
${databaseSpread}${databaseEntries.join('\n')}
        },
        cache: {
${cacheSpread}${cacheEntries.join('\n')}
        },
    },
    plugins: {
${pluginsSpread}${pluginEntries.join('\n')}
    },
    compaction: {
${compactionSpread}${compactionEntries.join('\n')}
    },
    logger: ${loggerExpression},
};

export default image;`;
}

function generateTypeDefinitions(definition: ImageDefinition): string {
    const sections: string[] = [];

    // Wildcard utility exports
    if (definition.utils && Object.keys(definition.utils).length > 0) {
        sections.push('// Utility re-exports');
        for (const path of Object.values(definition.utils)) {
            sections.push(`export * from '${path}';`);
        }
    }

    // Selective named exports
    if (definition.exports && Object.keys(definition.exports).length > 0) {
        if (sections.length > 0) sections.push('');
        sections.push('// Selective package re-exports');
        for (const [packageName, exports] of Object.entries(definition.exports)) {
            // Check for wildcard re-export
            if (exports.length === 1 && exports[0] === '*') {
                sections.push(`export * from '${packageName}';`);
                continue;
            }

            sections.push(`export {`);
            sections.push(`    ${exports.join(',\n    ')}`);
            sections.push(`} from '${packageName}';`);
        }
    }

    const utilityExports = sections.length > 0 ? '\n\n' + sections.join('\n') : '';

    return `// AUTO-GENERATED TypeScript definitions
// Do not edit this file directly

import type { DextoImageModule } from '@dexto/agent-config';

	/**
	 * Typed image module (no side effects)
	 */
	declare const image: DextoImageModule;
	export default image;
${utilityExports}
	`;
}
