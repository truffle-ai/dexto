import { z } from 'zod';
import { InternalTool, ToolExecutionContext } from '../../types.js';
import type { ResourceManager } from '../../../resources/manager.js';

/**
 * Input schema for list_resources tool
 */
const ListResourcesInputSchema = z
    .object({
        source: z
            .enum(['all', 'tool', 'user'])
            .optional()
            .default('all')
            .describe(
                'Filter by source: "tool" for tool-generated resources, "user" for user-uploaded, "all" for both'
            ),
        kind: z
            .enum(['all', 'image', 'audio', 'video', 'binary'])
            .optional()
            .default('all')
            .describe('Filter by type: "image", "audio", "video", "binary", or "all"'),
        limit: z
            .number()
            .optional()
            .default(50)
            .describe('Maximum number of resources to return (default: 50)'),
    })
    .strict();

type ListResourcesInput = z.output<typeof ListResourcesInputSchema>;

/**
 * Resource information returned to the agent
 *
 * The reference uses "blob:" prefix (not "@blob:") to avoid
 * triggering base64 expansion by expandBlobsInText() when this JSON
 * is serialized as a tool result.
 */
interface ResourceInfo {
    /** The blob reference (e.g., "blob:abc123") - use this with get_resource */
    reference: string;
    /** Resource type (image, audio, video, binary) */
    kind: string;
    /** MIME type */
    mimeType: string;
    /** Original filename if available */
    filename?: string;
    /** Source of the resource */
    source: 'tool' | 'user' | 'system';
    /** Size in bytes */
    size: number;
    /** When the resource was created */
    createdAt: string;
}

/**
 * Internal tool for listing available resources.
 *
 * This tool allows agents to discover what resources (images, files, etc.) are
 * available. Use this to find resources that can be accessed with get_resource.
 *
 * Resources are stored blobs from:
 * - Tool results (images generated by tools, screenshots, etc.)
 * - User uploads (files attached to messages)
 *
 * @example
 * ```typescript
 * // List all tool-generated images
 * list_resources({ source: 'tool', kind: 'image' })
 * â†’ { resources: [{ reference: 'blob:abc123', kind: 'image', ... }] }
 *
 * // Get a URL for sharing
 * get_resource({ reference: 'blob:abc123', format: 'url' })
 * ```
 */
export function createListResourcesTool(resourceManager: ResourceManager): InternalTool {
    return {
        id: 'list_resources',
        description:
            'List available resources (images, files, etc.). Returns resource references ' +
            'that can be used with get_resource to obtain shareable URLs or metadata. ' +
            'Filter by source (tool/user) or kind (image/audio/video/binary).',
        inputSchema: ListResourcesInputSchema,
        execute: async (input: unknown, _context?: ToolExecutionContext) => {
            const { source, kind, limit } = input as ListResourcesInput;

            try {
                const blobStore = resourceManager.getBlobStore();
                const allBlobs = await blobStore.listBlobs();

                // Filter and transform blobs
                const resources: ResourceInfo[] = [];

                for (const blob of allBlobs) {
                    // Skip system resources (internal prompts, etc.)
                    if (blob.metadata.source === 'system') {
                        continue;
                    }

                    // Filter by source
                    if (source !== 'all' && blob.metadata.source !== source) {
                        continue;
                    }

                    // Determine resource kind from MIME type
                    const mimeType = blob.metadata.mimeType;
                    let resourceKind: 'image' | 'audio' | 'video' | 'binary' = 'binary';
                    if (mimeType.startsWith('image/')) resourceKind = 'image';
                    else if (mimeType.startsWith('audio/')) resourceKind = 'audio';
                    else if (mimeType.startsWith('video/')) resourceKind = 'video';

                    // Filter by kind
                    if (kind !== 'all' && resourceKind !== kind) {
                        continue;
                    }

                    // Use blob.uri without @ prefix to avoid expansion by expandBlobsInText()
                    resources.push({
                        reference: blob.uri,
                        kind: resourceKind,
                        mimeType: blob.metadata.mimeType,
                        ...(blob.metadata.originalName && { filename: blob.metadata.originalName }),
                        source: blob.metadata.source || 'tool',
                        size: blob.metadata.size,
                        createdAt: blob.metadata.createdAt.toISOString(),
                    });
                }

                // Sort by creation time (newest first), then apply limit
                // This ensures we return the N newest resources, not arbitrary N resources
                resources.sort(
                    (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
                );
                const limitedResources = resources.slice(0, limit);

                return {
                    success: true,
                    count: limitedResources.length,
                    resources: limitedResources,
                    _hint:
                        limitedResources.length > 0
                            ? 'Use get_resource with a reference to get a shareable URL or metadata'
                            : 'No resources found matching the criteria',
                };
            } catch (error) {
                return {
                    success: false,
                    error: `Failed to list resources: ${error instanceof Error ? error.message : String(error)}`,
                    resources: [],
                };
            }
        },
    };
}
